<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>老六的大西瓜</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
    }
    body {
      background: #f0f8e8;
      font-family: "Microsoft YaHei", sans-serif;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #game-container {
      position: relative;
      width: 100%;
      flex: 1;
      background: #e0f0d0;
      overflow: hidden;
    }
    #score-board {
      padding: 10px;
      background: #4caf50;
      color: white;
      text-align: center;
      font-size: 1.2em;
      font-weight: bold;
    }
    #fail-line {
      position: absolute;
      top: 100px;
      left: 0;
      width: 100%;
      height: 2px;
      border-top: 2px dashed red;
      z-index: 10;
    }
    #game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      color: white;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20;
      font-size: 1.5em;
    }
    #restart-btn {
      margin-top: 20px;
      padding: 10px 20px;
      background: #ff9800;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 1.1em;
      cursor: pointer;
    }
    #start-tip {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 15px;
      border-radius: 10px;
      text-align: center;
      z-index: 15;
    }
  </style>
</head>
<body>
  <div id="score-board">得分: <span id="score">0</span></div>
  <div id="game-container">
    <div id="fail-line"></div>
    <div id="start-tip">老六，快投水果！</div>
    <div id="game-over">
      游戏结束！<br/>
      最终得分：<span id="final-score">0</span><br/>
      <button id="restart-btn">再玩一次</button>
    </div>
  </div>

  <!-- 引入 Matter.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const FRUIT_TYPES = [
        { name: '葡萄', size: 20, color: '#9c27b0', score: 2 },
        { name: '橙子', size: 30, color: '#ff9800', score: 4 },
        { name: '苹果', size: 40, color: '#f44336', score: 8 },
        { name: '奇异果', size: 50, color: '#4caf50', score: 16 },
        { name: '番茄', size: 60, color: '#e91e63', score: 32 },
        { name: '桃子', size: 70, color: '#ffc107', score: 64 },
        { name: '西瓜', size: 85, color: '#8bc34a', score: 128 }
      ];

      let score = 0;
      let gameOver = false;
      let gameStarted = false;
      let checkInterval = null;

      const Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Bodies = Matter.Bodies,
            World = Matter.World,
            Events = Matter.Events;

      const container = document.getElementById('game-container');
      const scoreEl = document.getElementById('score');
      const finalScoreEl = document.getElementById('final-score');
      const gameOverEl = document.getElementById('game-over');
      const restartBtn = document.getElementById('restart-btn');
      const startTip = document.getElementById('start-tip');

      const width = container.clientWidth;
      const height = container.clientHeight;
      const failLineY = 100;

      const engine = Engine.create({
        enableSleeping: false,
        gravity: { x: 0, y: 1 }
      });

      const runner = Runner.create({ isFixed: true, delta: 1000 / 60 });
      const render = Render.create({
        element: container,
        engine: engine,
        options: {
          width: width,
          height: height,
          wireframes: false,
          background: 'transparent',
          pixelRatio: window.devicePixelRatio || 1
        }
      });

      const ground = Bodies.rectangle(width / 2, height + 20, width, 40, { isStatic: true });
      const leftWall = Bodies.rectangle(-20, height / 2, 40, height * 2, { isStatic: true });
      const rightWall = Bodies.rectangle(width + 20, height / 2, 40, height * 2, { isStatic: true });
      World.add(engine.world, [ground, leftWall, rightWall]);

      function spawnFruit(x) {
        if (gameOver) return;
        const type = FRUIT_TYPES[0];
        const fruit = Bodies.circle(x, -50, type.size, {
          restitution: 0.6,
          friction: 0.01,
          frictionAir: 0.02,
          render: { fillStyle: type.color },
          itemType: type,
          label: 'fruit'
        });
        World.add(engine.world, fruit);
      }

      function checkCollisions() {
        if (gameOver) return;
        const fruits = engine.world.bodies.filter(b => b.itemType);
        for (let i = 0; i < fruits.length; i++) {
          for (let j = i + 1; j < fruits.length; j++) {
            const a = fruits[i];
            const b = fruits[j];
            if (!a.itemType || !b.itemType) continue;
            if (a.itemType.name !== b.itemType.name) continue;

            const dx = a.position.x - b.position.x;
            const dy = a.position.y - b.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDist = a.circleRadius + b.circleRadius;

            if (distance < minDist * 0.92) {
              const type = a.itemType;
              const index = FRUIT_TYPES.indexOf(type);
              World.remove(engine.world, [a, b]);
              score += type.score;
              scoreEl.textContent = score;

              if (index < FRUIT_TYPES.length - 1) {
                const newType = FRUIT_TYPES[index + 1];
                const posX = (a.position.x + b.position.x) / 2;
                const posY = (a.position.y + b.position.y) / 2;
                const newFruit = Bodies.circle(posX, posY, newType.size, {
                  restitution: 0.6,
                  friction: 0.01,
                  frictionAir: 0.02,
                  render: { fillStyle: newType.color },
                  itemType: newType,
                  label: 'fruit'
                });
                World.add(engine.world, newFruit);
              }
              return;
            }
          }
        }
      }

      Events.on(engine, 'afterUpdate', checkCollisions);

      function checkGameOver() {
        if (gameOver) return;
        for (const body of engine.world.bodies) {
          if (body.itemType && body.circleRadius) {
            if (body.position.y < 60) continue; // 忽略下落中的水果
            const topY = body.position.y - body.circleRadius;
            if (topY < failLineY) {
              endGame();
              return;
            }
          }
        }
      }

      function endGame() {
        gameOver = true;
        if (checkInterval) clearInterval(checkInterval);
        finalScoreEl.textContent = score;
        gameOverEl.style.display = 'flex';
        Runner.stop(runner);
      }

      function startGame() {
        if (gameStarted) return;
        gameStarted = true;
        startTip.style.display = 'none';
        Runner.run(runner, engine);
        Render.run(render);

        setTimeout(() => {
          if (!gameOver) {
            checkInterval = setInterval(checkGameOver, 300);
          }
        }, 1200);
      }

      container.addEventListener('pointerdown', (e) => {
        if (!gameStarted) startGame();
        if (gameOver) return;
        const rect = container.getBoundingClientRect();
        const x = e.clientX - rect.left;
        spawnFruit(x);
      });

      restartBtn.addEventListener('click', () => {
        if (checkInterval) clearInterval(checkInterval);
        score = 0;
        gameOver = false;
        gameStarted = true;
        scoreEl.textContent = '0';
        gameOverEl.style.display = 'none';

        const toRemove = engine.world.bodies.filter(b =>
          b !== ground && b !== leftWall && b !== rightWall
        );
        World.remove(engine.world, toRemove);

        Runner.run(runner, engine);
        Render.run(render);
        setTimeout(() => {
          if (!gameOver) {
            checkInterval = setInterval(checkGameOver, 300);
          }
        }, 1200);
      });
    });
  </script>
</body>
</html>

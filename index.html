<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>老六的大西瓜</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; touch-action: manipulation; }
    body {
      background: #f0f8e8;
      font-family: "Microsoft YaHei", sans-serif;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #game-container {
      position: relative;
      width: 100%;
      flex: 1;
      background: #e0f0d0;
      overflow: hidden;
    }
    #score-board {
      padding: 10px;
      background: #4CAF50;
      color: white;
      text-align: center;
      font-size: 1.2em;
      font-weight: bold;
    }
    #fail-line {
      position: absolute;
      top: 100px;
      left: 0;
      width: 100%;
      height: 2px;
      border-top: 2px dashed red;
      z-index: 10;
    }
    #game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      color: white;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20;
      font-size: 1.5em;
    }
    #restart-btn {
      margin-top: 20px;
      padding: 10px 20px;
      background: #FF9800;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 1.1em;
      cursor: pointer;
    }
    #start-btn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 15px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 1.5em;
      cursor: pointer;
      z-index: 15;
    }
    #start-tip {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 15px;
      border-radius: 10px;
      text-align: center;
      z-index: 10;
      display: none;
    }
  </style>
</head>
<body>
  <div id="score-board">得分: <span id="score">0</span></div>
  <div id="game-container">
    <div id="fail-line"></div>
    <!-- 添加开始按钮 -->
    <button id="start-btn">开始游戏</button>
    <!-- 添加游戏结束提示 -->
    <div id="game-over">
      游戏结束！<br/>
      最终得分：<span id="final-score">0</span><br/>
      <button id="restart-btn">再玩一次</button>
    </div>
    <!-- 添加开始提示 -->
    <div id="start-tip">老六，快投水果！</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // 定义水果类型
      const FRUIT_types = [
        { name: '葡萄', size: 20, score: 2 },
        { name: '橙子', size: 30, score: 4 },
        { name: '苹果', size: 40, score: 8 },
        { name: '奇异果', size: 50, score: 16 },
        { name: '番茄', size: 60, score: 32 },
        { name: '桃子', size: 70, score: 64 },
        { name: '西瓜', size: 85, score: 128 }
      ];

      let score = 0;
      let over = false;
      let started = false;
      let checkInterval = null;

      const Engine = Matter.Engine,
            Render = Matter Render,
            Runner = Matter Runner,
            Bodies = Matter.Bodies,
            World = Matter World,
            Events = Matter Events;

      const container = document.getElementById('game-container');
      const scoreEl = document.getElementById('score');
      const finalScoreEl = document.getElementById('final-score');
      const overDiv = document.getElementById('game-over');
      const restartBtn = document.getElementById('restart-btn');
      const startBtn = document.getElementById('start-btn');
      const startTip = document.getElementById('start-tip');

      const width = container.clientWidth;
      const height = container.clientHeight;
      const failLineY = 100;

      const engine = Engine.create({
        enableSleeping: false,
        gravity: { x: 0, y: 1 }
      });

      const runner = Runner.create({ isFixed: true, delta: 1000 / 60 });
      const render = Render.create({
        element: container,
        engine: engine,
        options: {
          width: width,
          height: height,
          wireframes: false,
          background: 'transparent',
          pixelRatio: window.devicePixelRatio || 1
        }
      });

      // 创建边界
      const ground = Bodies.rectangle(width / 2, height + 20, width, 40, { isStatic: true });
      const leftWall = Bodies.rectangle(-20, height / 2, 40, height * 2, { isStatic: true });
      const rightWall = Bodies.rectangle(width + 20, height / 2, 40, height * 2, { isStatic: true });
      World.add(engine世
      界, [ground, leftWall, rightWall]);

      // 生成水果函数
      function spawnFruit(x) {
        if (!started || over) return;

        const type = FRUIT_types[0];
        const fruit = Bodies.circle(x, -50, type.size, {
          restitution: 0.6,
          friction: 0.01,
          frictionAir: 0.02,
          render: {
            fillStyle: `hsl(${Math.random() * 360}, 70%, 50%)`
          },
          itemType: type,
          label: 'fruit'
        });
        World.add(engine世
        界, fruit);
      }

      // 碰撞检测与合并
      function checkCollisions() {
        if (!started || over) return;

        const fruits = engine世
        界.bodies.filter(b => b.itemType);
        for (let i = 0; i < fruits.length; i++) {
          for (let j = i + 1; j < fruits.length; j++) {
            const a = fruits[i];
            const b = fruits[j];
            if (!a.itemType || !b.itemType) continue;
            if (a.itemType.name !== b.itemType.name) continue;

            const dx = a.position.x - b.position.x;
            const dy = a.position.y - b.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDist = a.circleRadius + b.circleRadius;

            if (distance < minDist * 0.92) {
              const type = a.itemType;
              World.remove(engine世
              界, [a, b]);
              score += type.score;
              scoreEl.textContent = score;

              const index = FRUIT_types.indexOf(type);
              if (index < FRUIT_types.length - 1) {
                const newType = FRUIT_types[index + 1];
                const阳性X = (a.position.x + b.position.x) / 2;
                const阳性Y = (a.position.y + b.position.y) / 2;
                const newFruit = Bodies.circle(阳性X, 阳性Y, newType.size, {
                  restitution: 0.6,
                  friction: 0.01,
                  frictionAir: 0.02,
                  render: {
                    fillStyle: `hsl(${Math.random() * 360}, 70%, 50%)`
                  },
                  itemType: newType,
                  label: 'fruit'
                });
                World.add(engine世
                界, newFruit);
              }
              return;
            }
          }
        }
      }

      // 游戏结束检查
      function checkGAME
      OVER() {
        if (!started || over) return;

        for (const body of engine世
        界.bodies) {
          if (body.itemType && body.circleRadius) {
            if (body.position.y < 60) continue;
            const topY = body.position.y - body.circleRadius;
            if (topY < failLineY) {
              endGame();
              return;
            }
          }
        }
      }

      // 游戏结束函数
      function endGame() {
        over = true;
        started = false;

        if (checkInterval) clearInterval(checkInterval);
        finalScoreEl.textContent = score;
        overDiv.style.display = 'flex';
        Runner.stop runner
      }

      // 游戏开始函数
      function startGame() {
        console.log('开始游戏按钮被点击');

        if (over) {
          restartGame();
          return;
        }

        if (started) return;

        started = true;
        over = false;
        score = 0;
        scoreEl.textContent = '0';
        finalScoreEl.textContent = '0';

        // 清除已存在的物体
        const toRemove = engine世
        界.bodies.filter(b =>
          b !== ground && b !== leftWall && b !== rightWall
        );
        World.remove(engine世
        界, toRemove);

        // 启动物理引擎和渲染器
        Runner.run runner, engine
        Render.run render

        // 隐藏开始按钮，显示游戏区域
        startBtn.style.display = 'none';
        startTip.style.display = 'block';

        // 启动游戏结束检查
        setTimeout(() => {
          if (!over) {
            checkInterval = setInterval(checkGAME
            OVER, 300);
          }
        }, 1200);

        // 生成初始水果
        spawnFruit Math.random() * (width - 40) + 20
      }

      // 游戏重启函数
      function restartGame() {
        console.log('重启游戏按钮被点击');

        if (checkInterval) clearInterval(checkInterval);
        score = 0;
        over = false;
        started = true;
        scoreEl.textContent = '0';
        overDiv.style.display = 'none';

        // 清除所有物体
        const toRemove = engine世
        界.bodies.filter(b =>
          b !== ground && b !== leftWall && b !== rightWall
        );
        World.remove(engine世
        界, toRemove);

        // 重启引擎和渲染器
        Runner.run runner, engine
        Render.run render

        // 隐藏开始按钮，显示游戏区域
        startBtn.style.display = 'none';
        startTip.style.display = 'block';

        // 重新启动游戏结束检查
        setTimeout(() => {
          if (!over) {
            checkInterval = setInterval(checkGAME
            OVER, 300);
          }
        }, 1200);

        // 重新生成初始水果
        spawnFruit Math.random() * (width - 40) + 20
      }

      // 为开始按钮添加点击事件
      startBtn.addEventListener('click', startGame);

      // 为重启按钮添加点击事件
      restartBtn.addEventListener('click', restartGame);

      // 游戏容器点击事件（当游戏开始后）
      container.addEventListener('pointerdown', (e) => {
        if (!started || over) return;
        const rect = container.getBoundingClientRect();
        const x = e.clientX - rect.left;
        spawnFruit(x);
      });

      // 初始化渲染
      Render.run render

      // 初始化引擎
      Engine.run engine

      // 隐藏游戏结束界面
      overDiv.style.display = 'none';
    });
  </script>
</body>
</html>
